{"ast":null,"code":"/**\n * @fileoverview\n * @author Brandon Alexander - baalexander@gmail.com\n */\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n\nvar Message = require('./Message');\n/**\n * Publish and/or subscribe to a topic in ROS.\n *\n * Emits the following events:\n *  * 'warning' - if there are any warning during the Topic creation\n *  * 'message' - the message data from rosbridge\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * name - the topic name, like /cmd_vel\n *   * messageType - the message type, like 'std_msgs/String'\n *   * compression - the type of compression to use, like 'png', 'cbor', or 'cbor-raw'\n *   * throttle_rate - the rate (in ms in between messages) at which to throttle the topics\n *   * queue_size - the queue created at bridge side for re-publishing webtopics (defaults to 100)\n *   * latch - latch the topic when publishing\n *   * queue_length - the queue length at bridge side used when subscribing (defaults to 0, no queueing).\n *   * reconnect_on_close - the flag to enable resubscription and readvertisement on close event(defaults to true).\n */\n\n\nfunction Topic(options) {\n  options = options || {};\n  this.ros = options.ros;\n  this.name = options.name;\n  this.messageType = options.messageType;\n  this.isAdvertised = false;\n  this.compression = options.compression || 'none';\n  this.throttle_rate = options.throttle_rate || 0;\n  this.latch = options.latch || false;\n  this.queue_size = options.queue_size || 100;\n  this.queue_length = options.queue_length || 0;\n  this.reconnect_on_close = options.reconnect_on_close !== undefined ? options.reconnect_on_close : true; // Check for valid compression types\n\n  if (this.compression && this.compression !== 'png' && this.compression !== 'cbor' && this.compression !== 'cbor-raw' && this.compression !== 'none') {\n    this.emit('warning', this.compression + ' compression is not supported. No compression will be used.');\n    this.compression = 'none';\n  } // Check if throttle rate is negative\n\n\n  if (this.throttle_rate < 0) {\n    this.emit('warning', this.throttle_rate + ' is not allowed. Set to 0');\n    this.throttle_rate = 0;\n  }\n\n  var that = this;\n\n  if (this.reconnect_on_close) {\n    this.callForSubscribeAndAdvertise = function (message) {\n      that.ros.callOnConnection(message);\n      that.waitForReconnect = false;\n\n      that.reconnectFunc = function () {\n        if (!that.waitForReconnect) {\n          that.waitForReconnect = true;\n          that.ros.callOnConnection(message);\n          that.ros.once('connection', function () {\n            that.waitForReconnect = false;\n          });\n        }\n      };\n\n      that.ros.on('close', that.reconnectFunc);\n    };\n  } else {\n    this.callForSubscribeAndAdvertise = this.ros.callOnConnection;\n  }\n\n  this._messageCallback = function (data) {\n    that.emit('message', new Message(data));\n  };\n}\n\nTopic.prototype.__proto__ = EventEmitter2.prototype;\n/**\n * Every time a message is published for the given topic, the callback\n * will be called with the message object.\n *\n * @param callback - function with the following params:\n *   * message - the published message\n */\n\nTopic.prototype.subscribe = function (callback) {\n  if (typeof callback === 'function') {\n    this.on('message', callback);\n  }\n\n  if (this.subscribeId) {\n    return;\n  }\n\n  this.ros.on(this.name, this._messageCallback);\n  this.subscribeId = 'subscribe:' + this.name + ':' + ++this.ros.idCounter;\n  this.callForSubscribeAndAdvertise({\n    op: 'subscribe',\n    id: this.subscribeId,\n    type: this.messageType,\n    topic: this.name,\n    compression: this.compression,\n    throttle_rate: this.throttle_rate,\n    queue_length: this.queue_length\n  });\n};\n/**\n * Unregisters as a subscriber for the topic. Unsubscribing stop remove\n * all subscribe callbacks. To remove a call back, you must explicitly\n * pass the callback function in.\n *\n * @param callback - the optional callback to unregister, if\n *     * provided and other listeners are registered the topic won't\n *     * unsubscribe, just stop emitting to the passed listener\n */\n\n\nTopic.prototype.unsubscribe = function (callback) {\n  if (callback) {\n    this.off('message', callback); // If there is any other callbacks still subscribed don't unsubscribe\n\n    if (this.listeners('message').length) {\n      return;\n    }\n  }\n\n  if (!this.subscribeId) {\n    return;\n  } // Note: Don't call this.removeAllListeners, allow client to handle that themselves\n\n\n  this.ros.off(this.name, this._messageCallback);\n\n  if (this.reconnect_on_close) {\n    this.ros.off('close', this.reconnectFunc);\n  }\n\n  this.emit('unsubscribe');\n  this.ros.callOnConnection({\n    op: 'unsubscribe',\n    id: this.subscribeId,\n    topic: this.name\n  });\n  this.subscribeId = null;\n};\n/**\n * Registers as a publisher for the topic.\n */\n\n\nTopic.prototype.advertise = function () {\n  if (this.isAdvertised) {\n    return;\n  }\n\n  this.advertiseId = 'advertise:' + this.name + ':' + ++this.ros.idCounter;\n  this.callForSubscribeAndAdvertise({\n    op: 'advertise',\n    id: this.advertiseId,\n    type: this.messageType,\n    topic: this.name,\n    latch: this.latch,\n    queue_size: this.queue_size\n  });\n  this.isAdvertised = true;\n\n  if (!this.reconnect_on_close) {\n    var that = this;\n    this.ros.on('close', function () {\n      that.isAdvertised = false;\n    });\n  }\n};\n/**\n * Unregisters as a publisher for the topic.\n */\n\n\nTopic.prototype.unadvertise = function () {\n  if (!this.isAdvertised) {\n    return;\n  }\n\n  if (this.reconnect_on_close) {\n    this.ros.off('close', this.reconnectFunc);\n  }\n\n  this.emit('unadvertise');\n  this.ros.callOnConnection({\n    op: 'unadvertise',\n    id: this.advertiseId,\n    topic: this.name\n  });\n  this.isAdvertised = false;\n};\n/**\n * Publish the message.\n *\n * @param message - A ROSLIB.Message object.\n */\n\n\nTopic.prototype.publish = function (message) {\n  if (!this.isAdvertised) {\n    this.advertise();\n  }\n\n  this.ros.idCounter++;\n  var call = {\n    op: 'publish',\n    id: 'publish:' + this.name + ':' + this.ros.idCounter,\n    topic: this.name,\n    msg: message,\n    latch: this.latch\n  };\n  this.ros.callOnConnection(call);\n};\n\nmodule.exports = Topic;","map":{"version":3,"names":["EventEmitter2","require","Message","Topic","options","ros","name","messageType","isAdvertised","compression","throttle_rate","latch","queue_size","queue_length","reconnect_on_close","undefined","emit","that","callForSubscribeAndAdvertise","message","callOnConnection","waitForReconnect","reconnectFunc","once","on","_messageCallback","data","prototype","__proto__","subscribe","callback","subscribeId","idCounter","op","id","type","topic","unsubscribe","off","listeners","length","advertise","advertiseId","unadvertise","publish","call","msg","module","exports"],"sources":["/home/daeho/Documents/react/study/node_modules/roslib/src/core/Topic.js"],"sourcesContent":["/**\n * @fileoverview\n * @author Brandon Alexander - baalexander@gmail.com\n */\n\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\nvar Message = require('./Message');\n\n/**\n * Publish and/or subscribe to a topic in ROS.\n *\n * Emits the following events:\n *  * 'warning' - if there are any warning during the Topic creation\n *  * 'message' - the message data from rosbridge\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * name - the topic name, like /cmd_vel\n *   * messageType - the message type, like 'std_msgs/String'\n *   * compression - the type of compression to use, like 'png', 'cbor', or 'cbor-raw'\n *   * throttle_rate - the rate (in ms in between messages) at which to throttle the topics\n *   * queue_size - the queue created at bridge side for re-publishing webtopics (defaults to 100)\n *   * latch - latch the topic when publishing\n *   * queue_length - the queue length at bridge side used when subscribing (defaults to 0, no queueing).\n *   * reconnect_on_close - the flag to enable resubscription and readvertisement on close event(defaults to true).\n */\nfunction Topic(options) {\n  options = options || {};\n  this.ros = options.ros;\n  this.name = options.name;\n  this.messageType = options.messageType;\n  this.isAdvertised = false;\n  this.compression = options.compression || 'none';\n  this.throttle_rate = options.throttle_rate || 0;\n  this.latch = options.latch || false;\n  this.queue_size = options.queue_size || 100;\n  this.queue_length = options.queue_length || 0;\n  this.reconnect_on_close = options.reconnect_on_close !== undefined ? options.reconnect_on_close : true;\n\n  // Check for valid compression types\n  if (this.compression && this.compression !== 'png' &&\n    this.compression !== 'cbor' && this.compression !== 'cbor-raw' &&\n    this.compression !== 'none') {\n    this.emit('warning', this.compression +\n      ' compression is not supported. No compression will be used.');\n    this.compression = 'none';\n  }\n\n  // Check if throttle rate is negative\n  if (this.throttle_rate < 0) {\n    this.emit('warning', this.throttle_rate + ' is not allowed. Set to 0');\n    this.throttle_rate = 0;\n  }\n\n  var that = this;\n  if (this.reconnect_on_close) {\n    this.callForSubscribeAndAdvertise = function(message) {\n      that.ros.callOnConnection(message);\n\n      that.waitForReconnect = false;\n      that.reconnectFunc = function() {\n        if(!that.waitForReconnect) {\n          that.waitForReconnect = true;\n          that.ros.callOnConnection(message);\n          that.ros.once('connection', function() {\n            that.waitForReconnect = false;\n          });\n        }\n      };\n      that.ros.on('close', that.reconnectFunc);\n    };\n  }\n  else {\n    this.callForSubscribeAndAdvertise = this.ros.callOnConnection;\n  }\n\n  this._messageCallback = function(data) {\n    that.emit('message', new Message(data));\n  };\n}\nTopic.prototype.__proto__ = EventEmitter2.prototype;\n\n/**\n * Every time a message is published for the given topic, the callback\n * will be called with the message object.\n *\n * @param callback - function with the following params:\n *   * message - the published message\n */\nTopic.prototype.subscribe = function(callback) {\n  if (typeof callback === 'function') {\n    this.on('message', callback);\n  }\n\n  if (this.subscribeId) { return; }\n  this.ros.on(this.name, this._messageCallback);\n  this.subscribeId = 'subscribe:' + this.name + ':' + (++this.ros.idCounter);\n\n  this.callForSubscribeAndAdvertise({\n    op: 'subscribe',\n    id: this.subscribeId,\n    type: this.messageType,\n    topic: this.name,\n    compression: this.compression,\n    throttle_rate: this.throttle_rate,\n    queue_length: this.queue_length\n  });\n};\n\n/**\n * Unregisters as a subscriber for the topic. Unsubscribing stop remove\n * all subscribe callbacks. To remove a call back, you must explicitly\n * pass the callback function in.\n *\n * @param callback - the optional callback to unregister, if\n *     * provided and other listeners are registered the topic won't\n *     * unsubscribe, just stop emitting to the passed listener\n */\nTopic.prototype.unsubscribe = function(callback) {\n  if (callback) {\n    this.off('message', callback);\n    // If there is any other callbacks still subscribed don't unsubscribe\n    if (this.listeners('message').length) { return; }\n  }\n  if (!this.subscribeId) { return; }\n  // Note: Don't call this.removeAllListeners, allow client to handle that themselves\n  this.ros.off(this.name, this._messageCallback);\n  if(this.reconnect_on_close) {\n    this.ros.off('close', this.reconnectFunc);\n  }\n  this.emit('unsubscribe');\n  this.ros.callOnConnection({\n    op: 'unsubscribe',\n    id: this.subscribeId,\n    topic: this.name\n  });\n  this.subscribeId = null;\n};\n\n\n/**\n * Registers as a publisher for the topic.\n */\nTopic.prototype.advertise = function() {\n  if (this.isAdvertised) {\n    return;\n  }\n  this.advertiseId = 'advertise:' + this.name + ':' + (++this.ros.idCounter);\n  this.callForSubscribeAndAdvertise({\n    op: 'advertise',\n    id: this.advertiseId,\n    type: this.messageType,\n    topic: this.name,\n    latch: this.latch,\n    queue_size: this.queue_size\n  });\n  this.isAdvertised = true;\n\n  if(!this.reconnect_on_close) {\n    var that = this;\n    this.ros.on('close', function() {\n      that.isAdvertised = false;\n    });\n  }\n};\n\n/**\n * Unregisters as a publisher for the topic.\n */\nTopic.prototype.unadvertise = function() {\n  if (!this.isAdvertised) {\n    return;\n  }\n  if(this.reconnect_on_close) {\n    this.ros.off('close', this.reconnectFunc);\n  }\n  this.emit('unadvertise');\n  this.ros.callOnConnection({\n    op: 'unadvertise',\n    id: this.advertiseId,\n    topic: this.name\n  });\n  this.isAdvertised = false;\n};\n\n/**\n * Publish the message.\n *\n * @param message - A ROSLIB.Message object.\n */\nTopic.prototype.publish = function(message) {\n  if (!this.isAdvertised) {\n    this.advertise();\n  }\n\n  this.ros.idCounter++;\n  var call = {\n    op: 'publish',\n    id: 'publish:' + this.name + ':' + this.ros.idCounter,\n    topic: this.name,\n    msg: message,\n    latch: this.latch\n  };\n  this.ros.callOnConnection(call);\n};\n\nmodule.exports = Topic;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}