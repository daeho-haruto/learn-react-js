{"ast":null,"code":"'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\nvar warnedPrecision = false;\n\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n/**\n * Unpacks 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\n\n\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var arr = new Array(arrLen);\n\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n/**\n * Unpacks 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\n\n\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n  var arr = new Array(arrLen);\n\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n/**\n * Unpacks typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - desired output array type\n*/\n\n\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n/**\n * Support a subset of draft CBOR typed array tags:\n *   <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n * Only support little-endian tags for now.\n */\n\n\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\n\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n/**\n * Handles CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\n\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n\n  return data;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}","map":{"version":3,"names":["UPPER32","Math","pow","warnedPrecision","warnPrecision","console","warn","decodeUint64LE","bytes","byteLen","byteLength","offset","byteOffset","arrLen","buffer","slice","uint32View","Uint32Array","arr","Array","i","si","lo","hi","decodeInt64LE","int32View","Int32Array","decodeNativeArray","ArrayType","nativeArrayTypes","Uint8Array","Uint16Array","Int8Array","Int16Array","Float32Array","Float64Array","conversionArrayTypes","cborTypedArrayTagger","data","tag","arrayType","module","exports"],"sources":["/home/daeho/Documents/react/study/node_modules/roslib/src/util/cborTypedArrayTags.js"],"sourcesContent":["'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\n\nvar warnedPrecision = false;\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n\n/**\n * Unpacks 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si+1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n\n/**\n * Unpacks 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si+1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n\n/**\n * Unpacks typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - desired output array type\n*/\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n\n/**\n * Support a subset of draft CBOR typed array tags:\n *   <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n * Only support little-endian tags for now.\n */\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n\n/**\n * Handles CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n  return data;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}